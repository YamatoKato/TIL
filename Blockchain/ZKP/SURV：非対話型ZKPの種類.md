# 非対話型 ZKP の種類について

## 概要

- 日付: 2024-04-23
- キーワード: Blockchain,ZKP,NIZKP,zk-SNARKs,zk-STARKs

## 目的/背景

- Crypt 領域で非対話型 ZKP がどのように扱われているのか調べる。

- zk-SNARK と zk-STARK の違いを知る
  - どっちが有用なのか
- どこに強みがあるのか

## そもそも ZKP とは

ある情報の所有権や有効性を、**その情報自体を明らかにすることなく**証明する技術である。
したがって、ゼロ知識プロトコルは、2 つの当事者が個人情報を共有したくないシステムにおいて、プライバシーを簡素化し、信頼をもたらす。

ブロックチェーンのコンテキストでは、この性質を利用して主に、オフチェーン上で複数のトランザクションをまとめて検証し、ZKP を用いてオンチェーンと相互運用させてオンチェーンのスケーラビリティの向上を図っている。

## ゼロ知識プロトコルの基準

ゼロ知識プロトコルは、生成された ZKP が受け入れられることを保証するために、**完全性**、**健全性**、**ゼロ知識**の 3 つの重要な条件を遵守する必要がある。
![](https://storage.googleapis.com/zenn-user-upload/87ac25a794c6-20230505.png)

1. 完全性

   ゼロ知識プロトコルでの完全性とは、検証者が証明者の主張に挑戦するために使用するゼロ知識プロトコルが、その主張が実際に真実であることを疑いなく証明できるものでなければならないということである。つまり検証者が正直にプロトコルの規則に従って行動しなければならない

2. 健全性

   その主張が実際に真である場合にのみ、検証者に真値を返す。つまり、ZKP が健全であれば、不正を働く証明者は、正直な検証者を騙して偽の主張を真と見なすことは決してできない。

3. ゼロ知識

   検証者は、主張が真か偽かの他に、主張に関する追加情報を受け取ってはならない。

### 対話型 ZKP

![alt text](https://storage.googleapis.com/zenn-user-upload/ea41bf1516a3-20230505.png)

- 検証者が証明者と対話し、証明者の主張を検証する必要がある証明。
- そのために、検証者は、証明者が所有すると主張する秘密情報を所有している場合にのみ 解決または正しく回答できる一連の課題または質問を複数回、証明者に提示する。
- 検証者は、証明者に複数の課題を提示することができ、証明者が真の値を返すたびに、検証者は証明者の正直さに対する信頼が高まる。
  - しかし、検証者は 100%の確実性で主張を検証することはできないが、検証者が誤っ た主張を検証する可能性は、証明者が返す真値の数が増えるにつれて著しく減少。

### 非対話型 ZKP とは

![](https://storage.googleapis.com/zenn-user-upload/be071675b796-20230505.png)

- 検証者と証明者が合意したパラメータ(共有鍵) を用いて構築された暗号アルゴリズム で相互作用を代替。
- 証明者は、ZKP を生成するための計算を実行するアルゴリズムに情報(引数)を送る。
- 検証者は、その ZKP を別のアルゴリズムに入力し、証明が正しいかどうかを検証。

  - 言い換えると、証明者が一度の通信で証明を行い、検証者がその証明を独立して検証できるプロトコル
  - **証明者が検証者とリアルタイムに通信する必要がない!**
    => 非対話型

- プライバシーを重視したトランザクションの処理やオンチェーンのスケーラビリティ問題に対処するためのソリューションになり得る。
- しかし、暗号化された ZKP の生成と有効性の証明は、**計算機集約的**なプロセスになる。
  - TODO：ZKP 生成のための中央集権型プロセスを持つチェーンは、果たして分散性を持ったチェーンと呼べるのだろうか。
  - 検証者が数百のノードになることもあるブロックチェーンの分散性を考えると、非対話型 ZKP は対話型 ZKP よりもまだましな選択肢かも。
- 現在は **zk-SNARKs** と **zk-STARKs** の２種類に分かれている。

## zk-SNARKs

Zero-Knowledge Succinct Non-interactive Argument of Knowledge の略で訳はゼロ知識簡潔非対話的知識論証。2012 年に発明された。

SNARK とは、「検証者が証明者に問いを出すことなく、承認作業を短時間かつ少ない計算で行うことができる。」という概念。

- Zero-Knowledge：ゼロ知識証明を用いたスキームであること
- Succinct：実際に実行する計算量よりメッセージのサイズがとても小さいこと
- Non-interactive：証明者と承認者がリアルタイムで非対話な証明を行えること
- Argument of knowledge：計算による知識の証明のこと

### 手順

~~証明者 Alice は検証者 Bob と共有した参照値`x` と Alice しか知らない秘密の入力値 `w` を利用して、`y = f(x, w)`を計算して証明を生成する。Alice は計算結果`y`を秘密に保持し `f - y = 0` のみを 検証者 Bob に提供する。~~

~~検証者 Bob は Alice が正当な計算を行ったかどうかを確認したい。Bob は 検証者 Bob と共有した参照値 `x` と、Alice から提供される`f - y = 0` という 2 つの情報と、「秘密の入力値`w`を知っているということ」を Bob 自身が具体的に知らずに証明できる数学的なテクニックを利用して確認する。~~

~~これにより、検証者 Bob は 証明者 Alice が正当な計算を行ったことを確信し、Alice がちゃんと w を知っているということを、Bob にはゼロ知識で証明することができる。~~

![](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F81b1951c-a73d-40d4-8a72-002952cec3dd_889x510.png)

zk-SNARK は、以下の 3 つのアルゴリズムから成っています。

G：鍵を生成するアルゴリズム（ある秘密の値 R とプログラム C から証明鍵(pk)と承認鍵(vk)を生成する。(pk, vk) = G(R,C) ）

P：証明者が証明をするアルゴリズム（証明鍵(pk)と証明する情報(X)とプログラム C へのインプット(h)から証明(prf)を生成する。prf = P(pk, X, h) ）

V：承認者が証明を正当かどうか承認するアルゴリズム（承認鍵(vk)とプログラム C へのインプット(h)と証明(prf)から「正当か不正か」を返す。 V(vk, h, prf) = True or False ）

ざっくりと要約すると、以下のとおりです。

1. ある値「R」から証明用と承認用のキーをつくる

2. 証明キーと機密情報 X と X のハッシュ値から証明値をつくる

3. 承認者が承認キー、証明値、機密情報 X のハッシュ値を検証アルゴリズムにインプット

この結果が「真」であれば、X の内容を知らせずに承認者は情報の正否を検証できます。1 と 2 のアルゴリズムはオフチェーンで実行され、3 のアルゴリズムはスマートコントラクト内で実行され、その結果（真 or 偽）に応じて、オンチェーンコントラクトが実行するように仕組むことが可能です。

しかし、zk-SNARK の仕組みをみてみると以下のような課題があるといえます。

1. 「ある値 R」がバレてしまうと、証明キーも承認キーも割り出せてしまう

2. 1 回の情報のセットで 1 つの情報しかゼロ知識証明できないし、計算量が多い

3. キーの生成 G と証明値の生成アルゴリズム P の実行者が共謀していると検証結果を「真」に操作できる（Trusted setup）

以上のように zk-SNARK には課題があり、これを解決しつつ効率化したものが「zk-STARK」と呼ばれます。

### 特徴

メリット

- 証明のサイズが小さい(数百バイト)

  非常に小さな証明サイズを持ち、ブロックチェーン上でのトランザクションの検証に適している。

- 検証時間が短い

  証明の検証にかかる時間が短く、効率的なプロセスを提供できる。

デメリット

- 証明時間がかかる

  証明時間 150〜200k の constraints で laptopPC で 1 分かかる

- Trusted Setup が必要

  zk-SNARKs の生成には、信頼できるセットアップフェーズが必要になる。このフェーズでは複数人のセットアップパーティーが、チェーン側と Layer2 側の共通の参照点となる証明の生成と検証に必要なパラメータ(共通の参照文字列)とそれの生成に必要な暗号学的に重要な秘密な情報を生成する。もしセットアップが不正に行われた場合には、システムのセキュリティが損なわれるため、セットアップの完了後に安全に破棄される必要がある。

- 量子耐性の脆弱性

  現在の zk-SNARK は量子コンピュータに対して脆弱であるとされている。

### 何ができるのか

- 分散した情報の存在証明
- 秘匿化したまま情報を送受信する
- Tx やブロックを集約し、メインチェーンに刻む。
  - 俗に言う Layer2 Solution

=> 以下の問題の解決に役立つ

- スケーラビリティ
- インターオペラビリティ(相互運用性)
- プライバシー

### 応用例

別ページへ

## zk-STARKs

Zero-Knowledge Scalable Transparent Argument of Knowledge の略語で 2018 年に発明。

- S：「スケーラブル」を意味し、これらのゼロ知識証明がいかにブロックチェーンのスケーラビリティ強化に焦点を当てているかを強調している。
- T：「透明」の略

StarkNet で使用されている。

### 特徴

メリット

- Trusted Setup が必要ない
  - 内部の設計自体がハッシュ関数を基本としているので、公開検証可能なランダム性(実際には確実な計算)となり、必要ない。
- 量子コンピューター耐性
  - 量子耐性があるとされるハッシュ関数に依存しているため。
- 証明の計算複雑性が低い（オーダー的には snarks の 1/10 くらい）
- 検証者によって使用されるランダム性が公開されており、外部パラメータに依存せずに証明を検証できる

デメリット

- 証明サイズが大きい(~250kB: aurora)
  - スケーラビリティの向上と引き換え？
- 検証複雑性は snarks の setup 後よりは高い。

## SNARKs と STARKs の比較

|                                     | SNARKs                           | STARKs                        | Bulletproofs    |
| ----------------------------------- | -------------------------------- | ----------------------------- | --------------- |
| アルゴリズムの複雑さ: prover        | O(N \* log(N))                   | > O(N \* poly-log(N))         | O(N \* log(N))  |
| アルゴリズムの複雑さ: verifier      | ~O(1)                            | < O(poly-log(N))              | O(N)            |
| 通信の複雑さ（証明のサイズ）        | ~O(1)                            | < O(poly-log(N))              | O(log(N))       |
| 1 つのトランザクションのサイズ推定  | Tx: 200 bytes, Key: 50 MB        | 45 kB                         | 1.5 kb          |
| 10,000 トランザクションのサイズ推定 | Tx: 200 bytes, Key: 500 GB       | 135 kB                        | 2.5 kb          |
| Ethereum/EVM 検証ガスコスト         | ~600k (Groth16)                  | ~2.5M (estimate, no impl.)    | N/A             |
| Trusted Setup の必要性              | YES 😒                           | NO 😄                         | NO 😄           |
| ポスト量子安全性                    | NO 😒                            | YES 😄                        | NO 😒           |
| 暗号前提                            | DLP + secure bilinear pairing 😒 | Collision resistant hashes 😄 | Discrete log 😏 |

[Source](https://github.com/matter-labs/awesome-zero-knowledge-proofs?tab=readme-ov-file#comparison-of-the-most-popular-zkp-systems)

- スケーラビリティ

  zk-STARK は zk-SNARK よりも証明サイズがはるかに大きいが、zk-SNARK は計算量が多いため、他のオプションに比べて証明の生成が遅い。また、zk-SNARK は zk-STARK よりも消費ガスが少なく、証明の検証も高速である。

  zk-SNARK の方が証明の検証が速いためスケーラビリティが高いように見えるが、zk-STARK の方が証明サイズが大きいにもかかわらず、証明の生成が速く、実際のスケーリングも速い。さらに、zk-STARK はオフチェーンの計算とストレージを採用しているため、オンチェーン時に消費する 1 つ当たり Tx のガス量が少ない。しかし、スループットが低い（生成されるプルーフが少ない）時期には、検証にかなり時間がかかる。

- セキリュティ

  zk-SNARK は量子耐性がない。zk-STARK は trusted setup を必要とせず、代わりに衝突に強いハッシュ関数を用いて、高い計算コストを必要とせず、量子耐性を持つ。

- 透明性

  zk-SNARK は、 trusted setup を必要とする。これらのパラメータは通常、少人数のグループによって保護される。パラメータが悪人の手に渡ると、不正な行為者がそれを使って偽の証明を作成する可能性がある。

  zk-STARK は、衝突に強い暗号を利用することで、私的なパラメータ生成儀式を不要にしている。信頼できるセットアップがなければ、ランダム性を生成するためのパラメータは公開され、中央集権を制限し、透明性を高めることができる。

zk-SNARKs は「証明の生成は遅いが Proof のサイズが小さく検証が早い」と言われており、zk-STARKs は「証明の生成は早いが、Proof のサイズが大きく検証が遅い」といわれている。

また、zk-SNARKs は量子耐性がないと言われていますが、zk-STARKs は Trusted setup が必要ないことから量子耐性があると言われています。
加えて、zk-SNARKS は証明するデータが多くなると proof のサイズが大きくなってしまいますが、zkSTARKs だと証明するデータが多くなっても proof のサイズが変わらないため、zkSTARKs はスケーラビリティーがあると言われている。

ただ、ZKP 周りの技術の進展は早く Trusted Setup が必要ない zkSNARKs が出てたり、そもそも SNARKs と STARKs の比較自体がナンセンス

=> ZKP にはいろんな上記二種からいろいろな派生が誕生している。

## まとめ/所感/問題点

- それぞれメリットデメリットあって使い分けができると感じた
  - Ethereum の場合は L2 に zk-STARKs の利用を推したい
- TODO：ZKP 生成のための中央集権型プロセスを持つチェーンは、果たして分散性を持ったチェーンと呼べるのだろうか。
- zk-STARKs は Tx のサイズが増えれば増えるほど効果を発揮しそう。
  - TODO：まとめられて L2 に送られた Tx の塊のサイズ上限ってどのくらいなんだろうか？
- STARKs,SNARKs それぞれ開発用のライブラリがありそう。
  - libsnark - C++で書かれたライブラリで、zk-SNARKs のスキームを実装しています。このライブラリは、計算の整合性をゼロ知識で証明/検証するための暗号的手法を提供します
  - ZoKrates - Ethereum 上で zk-SNARKs を使用するためのツールボックスです。このツールは、zk-SNARKs の証明を生成し、検証するための高レベルな抽象化を提供します
  - snarkjs - JavaScript で書かれたライブラリで、Web ブラウザや Node.js 環境で zk-SNARKs の証明を生成および検証する機能を提供します
  - Cairo - STARKs を構築するためのプログラミング言語で、StarkNet プラットフォーム上で使用されます。Cairo は、STARKs に基づくプログラムを作成するためのリソースとツールを提供します
  - libSTARK - C++で書かれた ZK-STARK ライブラリで、STARKs の証明システムを実装しています。このライブラリは、STARKs の開発と実装に役立つツールを提供します
  - starknet.py - Python ライブラリで、StarkNet とのインタラクションを容易にするためのツールを提供します。これにより、Python を使用して STARKs ベースのアプリケーションを開発することが可能になります
  - Circom - ZKP アプリケーションの算術回路を計算するために特化したプログラミング言語。SNARKs 特化である。
- TODO: STARKs,SNARKs それぞれ何ができてできないのか調査する。
- TODO: 集約署名を使えばいらなくね問題

## 参考資料

- [zk-SNARKs vs zk-STARKs: Comparing Zero-knowledge Proofs](https://blog.pantherprotocol.io/zk-snarks-vs-zk-starks-differences-in-zero-knowledge-technologies/)
- [【完全保存版】ゼロ知識証明とは何か？](https://zenn.dev/thirdweb_jp/articles/bde586f0f56f9f)
- [zk-SNARKs の仕組みについて](https://www.slideshare.net/ssuser2530a7/zksnarks)
- [zk-SNARKs と zk-STARKs の比較](https://scrapbox.io/layerx/zk-SNARKs%E3%81%A8zk-STARKs%E3%81%AE%E6%AF%94%E8%BC%83)
